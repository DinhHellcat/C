 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\com.st.stm32cube.ide.mcu.informationcenter\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\com.st.stm32cube.ide.mcu.livewatch\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.dsf.ui\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.flatpak.launcher\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.make.core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.make.ui\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.managedbuilder.core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.cdt.ui\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\0\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\10\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\12\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\14\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\15\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\17\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\18\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\19\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\1c\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\2\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\22\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\23\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\25\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\26\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\27\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\28\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\2b\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\2c\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\2d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\2e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\30\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\32\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\33\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\34\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\36\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\37\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\38\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\39\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\3a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\3c\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\3d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\3f\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\41\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\43\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\47\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\48\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\4a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\4e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\51\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\52\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\53\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\54\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\55\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\56\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\57\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\58\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\5b\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\5d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\5e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\61\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\63\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\64\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\66\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\67\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\68\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6b\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6c\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\6e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\7\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\70\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\71\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\73\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\75\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\76\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\77\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\78\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\79\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\7a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\7d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\7e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\80\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\82\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\83\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\84\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\87\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\88\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\8a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\8d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\8e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\8f\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\90\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\91\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\94\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\96\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\97\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\99\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\9b\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\9f\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a1\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a2\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a3\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a5\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\a6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\aa\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\ad\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b0\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b1\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b2\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b3\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b5\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\b8\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\ba\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\bc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\bd\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\be\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\bf\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\c1\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\c2\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\c4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\c6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\c9\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\cf\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d0\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d2\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d7\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d8\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\d9\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\db\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\dd\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\df\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e0\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e1\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e5\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e7\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e8\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\e9\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f1\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f3\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f5\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f6\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\f9\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\fb\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\fd\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\fe\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.history\ff\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\0-test\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\0-test\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\1-BoardTesting\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\1-BoardTesting\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\10-Combined_System\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\10-Combined_System\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\11.Finale\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\11.Finale\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\11.Finale\.indexes\af\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\11.Finale\.indexes\bf\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\11.Finale\.indexes\bf\c4\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\2-Buzzer\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\2-Buzzer\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3-ServoPWM\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3.1-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3.1-ServoPWM\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3.2-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\3.2-ServoPWM\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\4-PIR\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\4-PIR\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\5-DHT22_with_LCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\5-DHT22_with_LCD\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\6.1-MQ2withLCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\6.1-MQ2withLCD\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\6.2-MQ135_with_LCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\6.2-MQ135_with_LCD\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\7.1-Combine_test\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\7.1-Combine_test\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\7.2-Combine_test_with interupt\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\7.2-Combine_test_with interupt\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\8.Wifi_module\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\8.Wifi_module\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\9-Wifi_with_Local_API\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.projects\9-Wifi_with_Local_API\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.root\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.root\.indexes\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.resources\.safetable\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.runtime\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.core.runtime\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.debug.core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.debug.ui\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.e4.workbench\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.equinox.p2.ui\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\10\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\10\42\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\9\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\9\38\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.core.refactoring\.refactorings\.workspace\2025\9\40\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ltk.ui.refactoring\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.search\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ui.editors\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ui.ide\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ui.intro\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ui.workbench\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.ui.workbench.texteditor\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\.metadata\.plugins\org.eclipse.userstorage.oauth\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim11;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM11_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM11_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
//	  HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_9); // Đèn LED trên board
//	    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_9); // Đèn LED cắm ngoài ở chân PB9
	      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET);

	    HAL_Delay(500);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM11 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM11_Init(void)
{

  /* USER CODE BEGIN TIM11_Init 0 */

  /* USER CODE END TIM11_Init 0 */

  /* USER CODE BEGIN TIM11_Init 1 */

  /* USER CODE END TIM11_Init 1 */
  htim11.Instance = TIM11;
  htim11.Init.Prescaler = 0;
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim11.Init.Period = 65535;
  htim11.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim11.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM11_Init 2 */

  /* USER CODE END TIM11_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_Pin */
  GPIO_InitStruct.Pin = LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\0-test\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Core\Src\main.c 
#include "main.h"

void SystemClock_Config(void);
static void MX_GPIO_Init(void);

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();

  while (1)
  {
    HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
    HAL_Delay(500);
  }
}

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    Error_Handler();

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
    Error_Handler();
}

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\1-BoardTesting\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define WIFI_SSID       "Herukyatto"
#define WIFI_PASSWORD   "1234567890"
#define LOCAL_API_IP    "192.168.137.1"
#define LOCAL_API_PORT  5000
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

I2C_HandleTypeDef hi2c1;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim4;

UART_HandleTypeDef huart6;

/* USER CODE BEGIN PV */
I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;
float temperature, humidity;
uint8_t uart_rx_byte;
char response_buffer[256];
uint8_t response_index = 0;
volatile uint8_t data_received_flag = 0;
volatile uint32_t ms_ticks = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM4_Init(void);
static void MX_USART6_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void LCD_Init_Custom()
{
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);
}

int send_at_command(const char* command, const char* expected_response, uint32_t timeout)
{
    memset(response_buffer, 0, sizeof(response_buffer));
    response_index = 0;
    HAL_UART_Transmit(&huart6, (uint8_t*)command, strlen(command), 1000);

    uint32_t start_time = HAL_GetTick();
    while (HAL_GetTick() - start_time < timeout)
    {
        if (strstr(response_buffer, expected_response) != NULL)
        {
            return 1;
        }
    }
    return 0;
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  MX_TIM2_Init();
  MX_TIM4_Init();
  MX_USART6_UART_Init();
  /* USER CODE BEGIN 2 */
  // Khởi tạo module
    LCD_Init_Custom();
    DwtInit();
    dht22.DataPort = DHT22_GPIO_Port;
    dht22.DataPin = DHT22_Pin;
    dht22.Type = DHT22;
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);

    // --- KẾT NỐI WI-FI ---
    lcd_puts(&lcd, "Connecting WiFi...");
    send_at_command("AT+RST\r\n", "ready", 5000);
    HAL_Delay(2000);
    send_at_command("ATE0\r\n", "OK", 1000);
    HAL_Delay(500);
    send_at_command("AT+WMODE=1,1\r\n", "OK", 3000);
    HAL_Delay(500);

    char connect_command[100];
    sprintf(connect_command, "AT+WJAP=\"%s\",\"%s\"\r\n", WIFI_SSID, WIFI_PASSWORD);

    if (!send_at_command(connect_command, "+EVENT:WIFI_GOT_IP", 15000))
    {
      lcd_clear(&lcd);
      lcd_puts(&lcd, "WiFi Failed!");
      while(1);
    }

    lcd_clear(&lcd);
    lcd_puts(&lcd, "WiFi Connected!");
    HAL_Delay(2000);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
    while (1)
      {
        // 1. Đọc cảm biến
        DHT_GetData(&dht22);
        temperature = dht22.Temperature;
        humidity = dht22.Humidity;

        // Hiển thị lên LCD
        lcd_clear(&lcd);
        char line1_str[20], line2_str[20];
        sprintf(line1_str, "Temp: %.1f C", temperature);
        sprintf(line2_str, "Humi: %.1f %%", humidity);
        lcd_puts(&lcd, line1_str);
        lcd_gotoxy(&lcd, 0, 1);
        lcd_puts(&lcd, line2_str);

        // 2. Chuẩn bị và gửi API
        char json_payload[100];
        // Tạo chuỗi JSON, ký tự \ dùng để escape dấu " trong chuỗi C
        sprintf(json_payload, "{\\\"temperature\\\":%.1f,\\\"humidity\\\":%.1f}", temperature, humidity);

        char http_command[300]; // Tăng kích thước buffer một chút
        // Thêm cặp dấu ngoặc kép "" bao quanh tham số data cuối cùng
        sprintf(http_command, "AT+HTTPCLIENTLINE=1,3,\"application/json\",\"%s\",%d,\"/api/data\",\"%s\"\r\n",
                LOCAL_API_IP, LOCAL_API_PORT, json_payload);

        // 3. Gửi dữ liệu và hiển thị trạng thái
        lcd_gotoxy(&lcd, 12, 1);
        lcd_puts(&lcd, "->");
        if(send_at_command(http_command, "OK", 10000)) {
            lcd_puts(&lcd, "OK");
        } else {
            lcd_puts(&lcd, "FAIL");
        }

        HAL_Delay(10000);
      }  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_84CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 19999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 99;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 999;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : PIR_Pin DHT22_Pin */
  GPIO_InitStruct.Pin = PIR_Pin|DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART6)
  {
    // Chỉ ghép ký tự vào bộ đệm, không đặt cờ báo nữa
    if (response_index < sizeof(response_buffer) - 1)
    {
      // Thay thế ký tự xuống dòng bằng dấu cách để dễ hiển thị trên 1 dòng
      if(uart_rx_byte == '\r' || uart_rx_byte == '\n')
      {
          if (response_index > 0) // Chỉ đặt cờ nếu đã có dữ liệu
          {
        	  data_received_flag = 1;
          }
      }
      else
      {
          response_buffer[response_index++] = uart_rx_byte;
      }
    } else {
    	// Tràn bộ đệm, reset lại
    	response_index = 0;
    }

    // Luôn lắng nghe byte tiếp theo
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);
  }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\10-Combined_System\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Core\Src\main.c 
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Chương trình chính cho hệ thống nhà thông minh (Phiên bản mini project)
  * @author         :
  * @version        : 1.0
  ******************************************************************************
  * @attention
  *
  * Đây là phiên bản tổng hợp, kết hợp các kỹ thuật:
  * - Lập trình không-chặn (Non-blocking) sử dụng Timer Interrupt (TIM4).
  * - Đọc ADC hiệu năng cao với DMA ở chế độ Circular.
  * - Giao tiếp UART không-chặn với WiFi module sử dụng Interrupt.
  * - Điều khiển Servo bằng PWM.
  * - Tích hợp các cảm biến: DHT22, PIR, MQ-2, MQ-135.
  * - Hiển thị thông tin qua I2C LCD.
  * - Máy trạng thái (State Machine) để quản lý logic chương trình.
  *
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
#include <string.h>

/* Private defines -----------------------------------------------------------*/
#define WIFI_SSID       "Herukyatto"
#define WIFI_PASSWORD   "1234567890"
#define LOCAL_API_IP    "10.13.7.9" // Thay đổi IP nếu cần
#define LOCAL_API_PORT  5000

#define GAS_ALARM_THRESHOLD 1500 // Ngưỡng cảnh báo gas
#define MAIN_LOGIC_INTERVAL 1000 // Thời gian thực thi logic chính (ms)
#define API_SEND_INTERVAL   10000 // Thời gian giữa 2 lần gửi API (ms)

/* Private typedef -----------------------------------------------------------*/
typedef enum {
    APP_STATE_INIT,
    APP_STATE_WIFI_CONNECT,
    APP_STATE_RUNNING
} AppState_t;

/* Private variables ---------------------------------------------------------*/
// --- Handles cho các ngoại vi và thư viện ---
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;
I2C_HandleTypeDef hi2c1;
TIM_HandleTypeDef htim2; // Dùng cho Servo PWM
TIM_HandleTypeDef htim4; // Dùng cho "nhịp tim" hệ thống
UART_HandleTypeDef huart6; // Dùng cho WiFi Module

I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;

// --- Biến cho hệ thống và logic không-chặn ---
volatile uint32_t ms_ticks = 0; // Biến "nhịp tim", được tăng trong ngắt TIM4
uint32_t last_main_logic_time = 0;
uint32_t last_api_send_time = 0;
AppState_t app_state = APP_STATE_INIT;

// --- Biến lưu giá trị cảm biến ---
float temperature = 0.0f, humidity = 0.0f;
uint32_t pir_state = 0;
uint32_t adc_dma_buffer[2]; // Buffer cho DMA: [0] = MQ-2, [1] = MQ-135

// --- Biến cho giao tiếp UART ---
uint8_t uart_rx_byte;
char response_buffer[256];
uint8_t response_index = 0;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM4_Init(void);
static void MX_USART6_UART_Init(void);

static void Manual_DMA_Link_Init(void); // Hàm khắc phục lỗi liên kết DMA
static int send_at_command(const char* command, const char* expected_response, uint32_t timeout);

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- 1. KHỞI TẠO CƠ BẢN --- */
  HAL_Init();
  SystemClock_Config();

  /* --- 2. KHỞI TẠO CÁC NGOẠI VI --- */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  MX_TIM2_Init();
  MX_TIM4_Init();
  MX_USART6_UART_Init();

  /* --- 3. KHỞI TẠO CÁC THƯ VIỆN VÀ TIẾN TRÌNH NỀN --- */
  DwtInit(); // Khởi tạo DWT cho các hàm delay us

  // Khởi tạo LCD
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);
  lcd_puts(&lcd, "System Init...");

  // Khởi tạo DHT22
  dht22.DataPort = DHT22_GPIO_Port;
  dht22.DataPin = DHT22_Pin;
  dht22.Type = DHT22;

  // Sửa lỗi liên kết ADC-DMA và bắt đầu đọc
  Manual_DMA_Link_Init();
  HAL_ADC_Start_DMA(&hadc1, adc_dma_buffer, 2);

  // Bắt đầu các tiến trình không-chặn
  HAL_TIM_Base_Start_IT(&htim4);          // Bắt đầu "nhịp tim" hệ thống
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3); // Bắt đầu PWM cho servo
  HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1); // Bắt đầu lắng nghe UART

  // Thiết lập trạng thái ban đầu
  __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Servo ở vị trí 0 độ (đóng)
  app_state = APP_STATE_WIFI_CONNECT;

  /* --- 4. VÒNG LẶP CHÍNH (SUPER LOOP) --- */
  while (1)
  {
    /* Vòng lặp này chạy cực nhanh và không bị chặn bởi bất kỳ hàm delay nào.
     * Mọi logic đều được quản lý bởi máy trạng thái và các mốc thời gian.
     */
    switch (app_state)
    {
        case APP_STATE_WIFI_CONNECT:
        {
            lcd_clear(&lcd);
            lcd_puts(&lcd, "Connecting WiFi...");

            // Trình tự kết nối WiFi
//            send_at_command("AT+RST\r\n", "ready", 5000);
//            HAL_Delay(1000); // Delay ngắn cần thiết sau reset
//            send_at_command("ATE0\r\n", "OK", 1000);
//            send_at_command("AT+WMODE=1,1\r\n", "OK", 2000);
            send_at_command("AT+RSTORE\r\n", "OK", 5000);

            char connect_cmd[100];
            sprintf(connect_cmd, "AT+WJAP=\"%s\",\"%s\"\r\n", WIFI_SSID, WIFI_PASSWORD);

            if (send_at_command(connect_cmd, "+EVENT:WIFI_GOT_IP", 15000))
            {
                lcd_clear(&lcd);
                lcd_puts(&lcd, "WiFi Connected!");
                HAL_Delay(2000);
                app_state = APP_STATE_RUNNING; // Chuyển trạng thái thành công
                last_main_logic_time = ms_ticks; // Reset các mốc thời gian
                last_api_send_time = ms_ticks;
            }
            else
            {
                lcd_clear(&lcd);
                lcd_puts(&lcd, "WiFi Failed!");
                HAL_Delay(5000); // Chờ và thử lại
            }
            break;
        }

        case APP_STATE_RUNNING:
        {
            // Logic chính chỉ thực thi định kỳ, không làm liên tục
            if (ms_ticks - last_main_logic_time >= MAIN_LOGIC_INTERVAL)
            {
                last_main_logic_time = ms_ticks;

                // --- 1. ĐỌC DỮ LIỆU CẢM BIẾN ---
                DHT_GetData(&dht22);
                temperature = dht22.Temperature;
                humidity = dht22.Humidity;
                pir_state = HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin);
                uint32_t mq2_val = adc_dma_buffer[0];
                uint32_t mq135_val = adc_dma_buffer[1];

                char line1_str[20], line2_str[20];

                // --- 2. XỬ LÝ LOGIC ƯU TIÊN (STATE MACHINE) ---
                if (mq2_val > GAS_ALARM_THRESHOLD) // Ưu tiên 1: Cảnh báo gas
                {
                    HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_SET);
                    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 1500); // Mở cửa
                    sprintf(line1_str, "GAS DETECTED!");
                    sprintf(line2_str, "Value: %lu", mq2_val);
                }
                else if (pir_state == GPIO_PIN_SET) // Ưu tiên 2: Có chuyển động
                {
                    HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_SET);
                    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 1500); // Mở cửa
                    sprintf(line1_str, "Motion Detected");
                    sprintf(line2_str, "Door Opened");
                }
                else // Trạng thái bình thường
                {
                    HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);
                    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đóng cửa
                    sprintf(line1_str, "Temp: %.1f C", temperature);
                    sprintf(line2_str, "Humi: %.1f %%", humidity);
                }

                // --- 3. CẬP NHẬT LCD ---
                lcd_clear(&lcd);
                lcd_puts(&lcd, line1_str);
                lcd_gotoxy(&lcd, 0, 1);
                lcd_puts(&lcd, line2_str);
            }

            // Logic gửi API cũng thực thi định kỳ và độc lập
            if (ms_ticks - last_api_send_time >= API_SEND_INTERVAL)
            {
                last_api_send_time = ms_ticks;

                // Chuẩn bị payload JSON
                char json_payload[100];
                sprintf(json_payload, "{\\\"temperature\\\":%.1f,\\\"humidity\\\":%.1f}", temperature, humidity);

                // Chuẩn bị lệnh HTTP
                char http_cmd[300];
                sprintf(http_cmd, "AT+HTTPCLIENTLINE=1,3,\"application/json\",\"%s\",%d,\"/api/data\",\"%s\"\r\n",
                        LOCAL_API_IP, LOCAL_API_PORT, json_payload);

                // Gửi và hiển thị trạng thái
                lcd_gotoxy(&lcd, 12, 1); // Vị trí góc phải dưới
                if(send_at_command(http_cmd, "OK", 10000)) {
                    lcd_puts(&lcd, "->OK");
                } else {
                    lcd_puts(&lcd, "->FAIL");
                }
            }
            break;
        }

        case APP_STATE_INIT:
        default:
            // Trạng thái khởi tạo, không làm gì cả, chờ chuyển sang WIFI_CONNECT
            break;
    }
  }
}

/* --- CÁC HÀM KHỞI TẠO NGOẠI VI (MX_...) --- */
// (Giữ nguyên các hàm MX_... đã được tạo từ các project trước, tôi tổng hợp lại đây)

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; // CHỌN HSI
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; // NGUỒN CHO PLL LÀ HSI
  RCC_OscInitStruct.PLL.PLLM = 8; // 16MHz / 8 = 2MHz
  RCC_OscInitStruct.PLL.PLLN = 100; // 2MHz * 100 = 200MHz
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; // 200MHz / 2 = 100MHz (SYSCLK)
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; // LẤY XUNG TỪ PLL
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_ADC1_Init(void)
{
  ADC_ChannelConfTypeDef sConfig = {0};
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK) Error_Handler();

  sConfig.Channel = ADC_CHANNEL_0; // MQ-2 on PA0
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_84CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) Error_Handler();

  sConfig.Channel = ADC_CHANNEL_1; // MQ-135 on PA1
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) Error_Handler();
}

static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) Error_Handler();
}

static void MX_TIM2_Init(void) // Servo PWM Timer
{
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 19999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) Error_Handler();
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) Error_Handler();
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) Error_Handler();
  HAL_TIM_MspPostInit(&htim2);
}

static void MX_TIM4_Init(void) // System Heartbeat Timer
{
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 99; // For 1MHz clock
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 999;   // Interrupt every 1000 * 1us = 1ms
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK) Error_Handler();
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK) Error_Handler();
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK) Error_Handler();
}

static void MX_USART6_UART_Init(void)
{
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK) Error_Handler();
}

static void MX_DMA_Init(void)
{
  __HAL_RCC_DMA2_CLK_ENABLE();
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
}

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  GPIO_InitStruct.Pin = PIR_Pin|DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);
}

/* --- CÁC HÀM HỖ TRỢ VÀ CALLBACK --- */

/**
  * @brief  Hàm này được tạo ra để khắc phục lỗi generate code của CubeMX.
  */
static void Manual_DMA_Link_Init(void)
{
  hdma_adc1.Instance = DMA2_Stream0;
  hdma_adc1.Init.Channel = DMA_CHANNEL_0;
  hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
  hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
  hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
  hdma_adc1.Init.Mode = DMA_CIRCULAR;
  hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
  hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
  if (HAL_DMA_Init(&hdma_adc1) != HAL_OK) Error_Handler();
  __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
}

/**
  * @brief  Hàm gửi lệnh AT và chờ phản hồi (vẫn còn blocking).
  * @note   Trong một hệ thống phức tạp hơn, hàm này nên được viết lại
  * để không chặn (non-blocking). Nhưng với logic kết nối một lần
  * thì có thể chấp nhận được.
  */
int send_at_command(const char* command, const char* expected_response, uint32_t timeout)
{
    memset(response_buffer, 0, sizeof(response_buffer));
    response_index = 0;
    HAL_UART_Transmit(&huart6, (uint8_t*)command, strlen(command), 1000);

    uint32_t start_time = HAL_GetTick();
    while (HAL_GetTick() - start_time < timeout)
    {
        if (strstr(response_buffer, expected_response) != NULL)
        {
            return 1; // Success
        }
    }
    return 0; // Fail
}

/**
  * @brief  Callback được gọi mỗi khi một Timer kết thúc chu kỳ đếm.
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM4) // Kiểm tra có phải "nhịp tim" từ TIM4 không
  {
    ms_ticks++; // Tăng biến đếm mili giây
  }
}

/**
  * @brief  Callback được gọi mỗi khi nhận được 1 byte qua UART.
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART6)
  {
    if (response_index < sizeof(response_buffer) - 1)
    {
      response_buffer[response_index++] = uart_rx_byte;
    }
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1); // Lắng nghe byte tiếp theo
  }
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\11.Finale\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
	{
		HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
		HAL_GPIO_TogglePin(BUZZER_GPIO_Port, BUZZER_Pin);
		HAL_GPIO_TogglePin(RELAY_GPIO_Port, RELAY_Pin);
		HAL_Delay(1000);
	}
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, BUZZER_Pin|RELAY_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : BUZZER_Pin RELAY_Pin */
  GPIO_InitStruct.Pin = BUZZER_Pin|RELAY_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\2-Buzzer\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim11;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM11_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM11_Init();
  /* USER CODE BEGIN 2 */
  HAL_TIM_PWM_Start(&htim11, TIM_CHANNEL_1);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while(1)
    {
	  		/* USER CODE BEGIN 3 */
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  htim11.Instance->CCR1 = 0;
//  	  __HAL_TIM_SET_COMPARE(&htim11, TIM_CHANNEL_1, 0);
  		HAL_Delay(1000);

  	  htim11.Instance->CCR1 = 1000;
//  		__HAL_TIM_SET_COMPARE(&htim11, TIM_CHANNEL_1, 1000);
  		HAL_Delay(1000);

  	  htim11.Instance->CCR1 = 2000;
//  		__HAL_TIM_SET_COMPARE(&htim11, TIM_CHANNEL_1, 2000);
  		HAL_Delay(1000);

		HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
		HAL_Delay(1000);
		HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
		HAL_Delay(1000);
        /* USER CODE END WHILE */
      }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM11 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM11_Init(void)
{

  /* USER CODE BEGIN TIM11_Init 0 */

  /* USER CODE END TIM11_Init 0 */

  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM11_Init 1 */

  /* USER CODE END TIM11_Init 1 */
  htim11.Instance = TIM11;
  htim11.Init.Prescaler = 99;
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim11.Init.Period = 19999;
  htim11.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim11.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
//  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
//  {
//    Error_Handler();
//  }
  if (HAL_TIM_PWM_Init(&htim11) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim11, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM11_Init 2 */

  /* USER CODE END TIM11_Init 2 */
  HAL_TIM_MspPostInit(&htim11);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_ON_BOARD_Pin (PA9) */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* === ĐOẠN CODE THÊM VÀO ĐỂ SỬA LỖI === */
  /*Configure GPIO pin : SERVO_PWM_Pin (PB9) */
  GPIO_InitStruct.Pin = SERVO_PWM_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; // Chế độ Alternate Function Push-Pull
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF3_TIM11; // Kết nối chân này với TIM11
  HAL_GPIO_Init(SERVO_PWM_GPIO_Port, &GPIO_InitStruct);
  /* ======================================= */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim3;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM3_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM3_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);

  while (1)
  {
    /* USER CODE END WHILE */

	HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
	HAL_Delay(1000);

	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 1000);
	HAL_Delay(1000);

	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 1500);
	HAL_Delay(1000);

	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 2000);
	HAL_Delay(1000);

	HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
	HAL_Delay(1000);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 99;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 20000-1;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.1-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */

#define PULSE_TEST_VALUE 1500

int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM2_Init();
  /* USER CODE BEGIN 2 */
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
		HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
		HAL_Delay(1000);

		__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 500);
		HAL_Delay(1000);

		__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 1500);
		HAL_Delay(1000);

		__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 2500);
		HAL_Delay(1000);

		HAL_GPIO_TogglePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin);
		HAL_Delay(1000);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 100-1;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 20000-1;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\3.2-ServoPWM\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	  if (HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin) == GPIO_PIN_SET)
	    {
	      // Nếu có chuyển động (trạng thái là SET/HIGH), bật đèn LED on-board.
	      HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_SET);
	    }
	    else
	    {
	      // Nếu không có chuyển động (trạng thái là RESET/LOW), tắt đèn LED on-board.
	      HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);
	    }

	    // Thêm một khoảng nghỉ ngắn để giảm tải cho vi điều khiển
	    HAL_Delay(100);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PIR_Pin */
  GPIO_InitStruct.Pin = PIR_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(PIR_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\4-PIR\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"  // Thư viện LCD
#include "dhtxx.h"    // Thư viện DHT
#include <stdio.h>
#include <dwt.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;

TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */
I2C_LCD_HandleTypeDef lcd; // Biến điều khiển LCD
DHTxx_Drv_t dht22;       // Biến điều khiển DHT22

char temp_str[16];     // Chuỗi để hiển thị nhiệt độ
char hum_str[16];      // Chuỗi để hiển thị độ ẩm
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_TIM2_Init();
  /* USER CODE BEGIN 2 */
  DwtInit();
  // --- Khởi tạo LCD ---
    lcd.hi2c = &hi2c1;
    lcd.address = 0x4E; // Địa chỉ I2C của LCD (0x27 << 1)
    lcd_init(&lcd);

    lcd_puts(&lcd, "Dang khoi dong...");
    HAL_Delay(1500);
    lcd_clear(&lcd);

    // --- Khởi tạo DHT22 ---
    dht22.DataPort = DHT22_GPIO_Port; // Dùng macro CubeMX đã tạo
    dht22.DataPin = DHT22_Pin;
    dht22.Type = DHT22;
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
    while (1)
      {
    /* USER CODE END WHILE */
        /* USER CODE END WHILE */
//        // Đọc dữ liệu từ cảm biến DHT22
//        DHT_GetData(&dht22);
//
//        // Chuyển đổi giá trị số sang chuỗi để hiển thị
//        sprintf(temp_str, "Nhiet Do: %.1f C", dht22.Temperature);
//        sprintf(hum_str,  "Do Am:   %.1f %%", dht22.Humidity);
//
//        // Hiển thị lên LCD
//        lcd_gotoxy(&lcd, 0, 0); // Di chuyển con trỏ đến hàng 0, cột 0
//        lcd_puts(&lcd, temp_str); // In chuỗi nhiệt độ
//
//        lcd_gotoxy(&lcd, 0, 1); // Di chuyển con trỏ đến hàng 1, cột 0
//        lcd_puts(&lcd, hum_str);  // In chuỗi độ ẩm
//
//        HAL_Delay(2000); // Đợi 2 giây cho lần đọc tiếp theo
    	DHT_GetData(&dht22);

    	    // Kiểm tra xem việc đọc có thành công không
    	    // Nếu cả 2 giá trị vẫn là 0 sau khi đọc, tức là đã có lỗi
    	    if (dht22.Temperature == 0 && dht22.Humidity == 0)
    	    {
    	        lcd_clear(&lcd);
    	        lcd_gotoxy(&lcd, 0, 0);
    	        lcd_puts(&lcd, "Loi doc DHT22!");
    	        lcd_gotoxy(&lcd, 0, 1);
    	        lcd_puts(&lcd, "Kiem tra day noi");
    	    }
    	    else
    	    {
    	        // Chuyển đổi giá trị số sang chuỗi để hiển thị
    	        sprintf(temp_str, "Nhiet Do: %.1f C", dht22.Temperature);
    	        sprintf(hum_str,  "Do Am:   %.1f %%", dht22.Humidity);

    	        // Hiển thị lên LCD
    	        lcd_gotoxy(&lcd, 0, 0);
    	        lcd_puts(&lcd, temp_str);
    	        lcd_gotoxy(&lcd, 0, 1);
    	        lcd_puts(&lcd, hum_str);
    	    }

    	    HAL_Delay(2000);
    /* USER CODE BEGIN 3 */
      }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 4294967295;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin : DHT22_Pin */
  GPIO_InitStruct.Pin = DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(DHT22_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\5-DHT22_with_LCD\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"  // Thư viện LCD
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;

I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN PV */
I2C_LCD_HandleTypeDef lcd; // Biến điều khiển LCD

uint32_t adc_value;
char adc_str[16];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  /* USER CODE BEGIN 2 */
//  HAL_ADC_Start(&hadc1);
  // --- Khởi tạo LCD ---
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E; // Địa chỉ I2C của LCD (0x27 << 1)
  lcd_init(&lcd);

  lcd_puts(&lcd, "Dang khoi dong...");
  HAL_Delay(1500);
  lcd_clear(&lcd);

  lcd_clear(&lcd);
  lcd_gotoxy(&lcd, 0, 0);
  lcd_puts(&lcd, "MQ-2 Sensor");
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  // Đọc giá trị từ ADC (giờ nó sẽ luôn được cập nhật)
//	  	  adc_value = HAL_ADC_GetValue(&hadc1);
//
//	  	  // Định dạng chuỗi, thêm các khoảng trắng ở cuối để ghi đè lên số cũ
//	  	  sprintf(adc_str, "Gas Raw: %-5lu", adc_value); // %-5lu sẽ in số và căn lề trái trong 5 ký tự
//
//	  	  // Hiển thị lên LCD mà không cần xóa
//	  	  lcd_gotoxy(&lcd, 0, 0);
//	  	  lcd_puts(&lcd, "MQ-2 Sensor"); // Dòng này không đổi nên có thể đặt ra ngoài vòng lặp
//	  	  lcd_gotoxy(&lcd, 0, 1);
//	  	  lcd_puts(&lcd, adc_str);
//
//	  	  HAL_Delay(500); // Cập nhật mỗi nửa giây
	  // 1. Bắt đầu một lần chuyển đổi ADC
	    HAL_ADC_Start(&hadc1);

	    // 2. Chờ cho đến khi chuyển đổi hoàn tất (với timeout 100ms)
	    HAL_ADC_PollForConversion(&hadc1, 100);

	    // 3. Đọc giá trị đã chuyển đổi
	    adc_value = HAL_ADC_GetValue(&hadc1);

	    // 4. (Tùy chọn) Dừng ADC để tiết kiệm năng lượng
	    // HAL_ADC_Stop(&hadc1);


	    // --- Code hiển thị lên LCD (giữ nguyên như cũ) ---
	    sprintf(adc_str, "Gas Raw: %-5lu", adc_value);

	    lcd_gotoxy(&lcd, 0, 1);
	    lcd_puts(&lcd, adc_str);

	    HAL_Delay(500);
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.1-MQ2withLCD\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"  // Thư viện LCD
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;

I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN PV */
I2C_LCD_HandleTypeDef lcd; // Biến điều khiển LCD

uint32_t adc_value;
char adc_str[16];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  /* USER CODE BEGIN 2 */
  //  HAL_ADC_Start(&hadc1);
    // --- Khởi tạo LCD ---
    lcd.hi2c = &hi2c1;
    lcd.address = 0x4E; // Địa chỉ I2C của LCD (0x27 << 1)
    lcd_init(&lcd);

    lcd_puts(&lcd, "Dang khoi dong...");
    HAL_Delay(1500);
    lcd_clear(&lcd);

    lcd_clear(&lcd);
    lcd_gotoxy(&lcd, 0, 0);
    lcd_puts(&lcd, "MQ-2 Sensor");
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  HAL_ADC_Start(&hadc1);
	  	  HAL_ADC_PollForConversion(&hadc1, 100);
	  	  adc_value = HAL_ADC_GetValue(&hadc1);

	  	  // Định dạng chuỗi, đổi "Gas" thành "AQI" (Air Quality Index)
	  	  sprintf(adc_str, "AQI Raw: %-5lu", adc_value);

	  	  // Hiển thị lên LCD
	  	  lcd_gotoxy(&lcd, 0, 0);
	  	  lcd_puts(&lcd, "MQ-135 Sensor"); // Đổi tên cảm biến
	  	  lcd_gotoxy(&lcd, 0, 1);
	  	  lcd_puts(&lcd, adc_str);

	  	  HAL_Delay(500);
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\6.2-MQ135_with_LCD\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define GAS_ALARM_THRESHOLD 1000 // Ngưỡng báo động cho cảm biến MQ-2
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

I2C_HandleTypeDef hi2c1;

TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */
// --- Handles cho các thư viện và ngoại vi ---
I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;

// --- Biến lưu giá trị các cảm biến ---
float temperature, humidity;
uint32_t pir_state;
uint32_t adc_dma_buffer[2]; // Mảng chứa 2 giá trị ADC từ DMA

// --- Các chuỗi ký tự để hiển thị lên LCD ---
char line1_str[17];
char line2_str[17];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */
static void Manual_DMA_Link_Init(void); // Hàm cấu hình DMA bằng tay
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- KHỐI KHỞI TẠO CỦA STM32 --- */
  HAL_Init();
  SystemClock_Config();

  /* --- KHỞI TẠO CÁC NGOẠI VI ĐÃ CẤU HÌNH TRONG CUBEMX --- */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  MX_TIM2_Init();

  /* USER CODE BEGIN 2 */
  /* --- KHỞI TẠO CÁC THƯ VIỆN VÀ BẮT ĐẦU CÁC TIẾN TRÌNH --- */
  DwtInit();

  // Khởi tạo LCD
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);

  // Khởi tạo cảm biến DHT22
  dht22.DataPort = DHT22_GPIO_Port;
  dht22.DataPin = DHT22_Pin;
  dht22.Type = DHT22;

  // Cấu hình và liên kết DMA bằng tay để đảm bảo hoạt động
  Manual_DMA_Link_Init();

  // Bắt đầu quá trình đọc ADC bằng DMA
  HAL_ADC_Start_DMA(&hadc1, adc_dma_buffer, 2);

  // Bắt đầu phát xung PWM cho Servo
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);

  // Thiết lập trạng thái ban đầu cho các thiết bị
  __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đóng cửa
  lcd_puts(&lcd, "System ready!");
  HAL_Delay(2000);
  lcd_clear(&lcd);
  /* USER CODE END 2 */

  /* --- VÒNG LẶP CHÍNH CỦA CHƯƠNG TRÌNH --- */
  while (1)
  {
    /* --- 1. ĐỌC DỮ LIỆU TỪ TẤT CẢ CẢM BIẾN --- */
    DHT_GetData(&dht22);
    temperature = dht22.Temperature;
    humidity = dht22.Humidity;
    pir_state = HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin);

    // Lấy giá trị MQ-2 và MQ-135 trực tiếp từ bộ đệm DMA đã được cập nhật ở nền
    uint32_t mq2_value = adc_dma_buffer[0];
    uint32_t mq135_value = adc_dma_buffer[1];

    /* --- 2. XỬ LÝ LOGIC VÀ ĐIỀU KHIỂN (STATE MACHINE) --- */
    // Ưu tiên cao nhất: Báo động khí gas
    if (mq2_value > GAS_ALARM_THRESHOLD)
    {
      HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_SET);
      sprintf(line1_str, "CANH BAO GAS!  ");
      sprintf(line2_str, "Muc do: %-5lu", mq2_value);
    }
    // Ưu tiên thứ hai: Phát hiện chuyển động
    else if (pir_state == GPIO_PIN_SET)
    {
      HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_SET);
      HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
      __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 1500); // Mở cửa
      sprintf(line1_str, "Phat hien       ");
      sprintf(line2_str, "chuyen dong...  ");
    }
    // Trạng thái bình thường
    else
    {
      HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);
      HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
      __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đóng cửa
      sprintf(line1_str, "NhietDo: %.1f C", temperature);
      sprintf(line2_str, "AQI Raw: %-5lu", mq135_value);
    }

    /* --- 3. CẬP NHẬT MÀN HÌNH LCD --- */
    lcd_clear(&lcd);
    lcd_gotoxy(&lcd, 0, 0);
    lcd_puts(&lcd, line1_str);
    lcd_gotoxy(&lcd, 0, 1);
    lcd_puts(&lcd, line2_str);

    HAL_Delay(1000);
  }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
  ADC_ChannelConfTypeDef sConfig = {0};

  // Cấu hình ADC chung
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE; // Bật yêu cầu DMA liên tục
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  // Cấu hình kênh 1 (Rank 1) cho MQ-2 (PA0)
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_84CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  // Cấu hình kênh 2 (Rank 2) cho MQ-135 (PA1)
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 19999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; // Bật Preload
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) // Chỉ dùng PWM_Init là đủ
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 500; // Đặt giá trị ban đầu
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  HAL_TIM_MspPostInit(&htim2);
}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : BUZZER_Pin */
  GPIO_InitStruct.Pin = BUZZER_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(BUZZER_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PIR_Pin DHT22_Pin */
  GPIO_InitStruct.Pin = PIR_Pin|DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : SERVO_Pin */
  GPIO_InitStruct.Pin = SERVO_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  HAL_GPIO_Init(SERVO_GPIO_Port, &GPIO_InitStruct);

  /* === BỔ SUNG CẤU HÌNH CHO 2 CHÂN ADC (PA0, PA1) === */
  GPIO_InitStruct.Pin = MQ_2_Pin|MQ_135_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG; // Chế độ Analog
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  /* ================================================= */
}

/* USER CODE BEGIN 4 */
/**
  * @brief  Hàm cấu hình và liên kết DMA với ADC một cách thủ công.
  * @note   Hàm này được tạo ra để khắc phục lỗi generate code của CubeMX,
  * đảm bảo ADC và DMA luôn được liên kết đúng cách.
  * @retval None
  */
static void Manual_DMA_Link_Init(void)
{
  // 1. Cấu hình chi tiết cho luồng DMA mà ADC1 sẽ sử dụng
  hdma_adc1.Instance = DMA2_Stream0;
  hdma_adc1.Init.Channel = DMA_CHANNEL_0;
  hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
  hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
  hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
  hdma_adc1.Init.Mode = DMA_CIRCULAR;
  hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
  hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
  if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
  {
    Error_Handler();
  }

  // 2. "Giới thiệu" ADC với DMA. Đây là bước quan trọng nhất!
  __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.1-Combine_test\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "main.h"
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

I2C_HandleTypeDef hi2c1;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim4;

/* USER CODE BEGIN PV */
// --- Handles ---
I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;

// --- Biến đếm nhịp tim hệ thống ---
volatile uint32_t ms_ticks = 0;

// --- Biến lưu giá trị cảm biến ---
float temperature, humidity;
uint32_t pir_state;
uint32_t adc_dma_buffer[2];

// --- Biến cho logic không-chặn ---
uint32_t last_lcd_update_time = 0;

// --- Chuỗi hiển thị ---
char line1_str[17];
char line2_str[17];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM2_Init(void);
static void MX_I2C1_Init(void);
static void MX_TIM4_Init(void);
/* USER CODE BEGIN PFP */
static void Manual_DMA_Link_Init(void);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_TIM2_Init();
  MX_I2C1_Init();
  MX_TIM4_Init();
  /* USER CODE BEGIN 2 */
  // Khởi tạo thư viện
    DwtInit();
    // Cấu hình và liên kết DMA bằng tay để đảm bảo hoạt động
    Manual_DMA_Link_Init();
    lcd.hi2c = &hi2c1;
    lcd.address = 0x4E;
    lcd_init(&lcd);
    dht22.DataPort = DHT22_GPIO_Port;
    dht22.DataPin = DHT22_Pin;
    dht22.Type = DHT22;

    // Bắt đầu các tiến trình nền
    HAL_TIM_Base_Start_IT(&htim4); // Bắt đầu nhịp tim (TIM4)
    HAL_ADC_Start_DMA(&hadc1, adc_dma_buffer, 2);
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);

    // Thiết lập trạng thái ban đầu
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đóng cửa
    lcd_puts(&lcd, "System ready!");
    HAL_Delay(2000);
    lcd_clear(&lcd);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  // Logic trong này chạy cực nhanh, vòng lặp không bị chặn

	      // Khối logic chính chỉ thực thi mỗi 1 giây (1000ms)
	      if (ms_ticks - last_lcd_update_time >= 1000)
	      {
	        last_lcd_update_time = ms_ticks; // Đặt lại mốc thời gian

	        // 1. ĐỌC DỮ LIỆU CẢM BIẾN
	        DHT_GetData(&dht22);
	        temperature = dht22.Temperature;
	        humidity = dht22.Humidity;
	        pir_state = HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin);
	        uint32_t mq2_value = adc_dma_buffer[0];
	        uint32_t mq135_value = adc_dma_buffer[1];

	        // 2. XỬ LÝ LOGIC VÀ ĐIỀU KHIỂN
	        if (mq2_value > 1000) // Ngưỡng báo động gas
	        {
	          HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_SET);
	          sprintf(line1_str, "CANH BAO GAS!  ");
	          sprintf(line2_str, "Muc do: %-5lu", mq2_value);
	        }
	        else if (pir_state == GPIO_PIN_SET)
	        {
	          HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
	          __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 1500); // Mở cửa
	          sprintf(line1_str, "Phat hien       ");
	          sprintf(line2_str, "chuyen dong...  ");
	        }
	        else
	        {
	          HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
	          __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đóng cửa
	          sprintf(line1_str, "NhietDo: %.1f C ", temperature);
	          sprintf(line2_str, "AQI Raw: %-5lu ", mq135_value);
	        }

	        // 3. CẬP NHẬT MÀN HÌNH LCD
	        lcd_clear(&lcd);
	        lcd_gotoxy(&lcd, 0, 0);
	        lcd_puts(&lcd, line1_str);
	        lcd_gotoxy(&lcd, 0, 1);
	        lcd_puts(&lcd, line2_str);
	      }
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_84CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 19999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 99;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 999;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : BUZZER_Pin */
  GPIO_InitStruct.Pin = BUZZER_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(BUZZER_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PIR_Pin DHT22_Pin */
  GPIO_InitStruct.Pin = PIR_Pin|DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* === BỔ SUNG CẤU HÌNH CHO SERVO VÀ ADC === */
  /*Configure GPIO pin : SERVO_Pin */
  GPIO_InitStruct.Pin = SERVO_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  HAL_GPIO_Init(SERVO_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : MQ_2_Pin MQ_135_Pin */
  GPIO_InitStruct.Pin = MQ2_Pin|MQ135_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  /* ======================================= */
}

/* USER CODE BEGIN 4 */
/**
  * @brief  Cấu hình và liên kết DMA với ADC một cách thủ công.
  */
static void Manual_DMA_Link_Init(void)
{
  // 1. Cấu hình chi tiết cho luồng DMA
  hdma_adc1.Instance = DMA2_Stream0;
  hdma_adc1.Init.Channel = DMA_CHANNEL_0;
  hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
  hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
  hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
  hdma_adc1.Init.Mode = DMA_CIRCULAR;
  hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
  hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
  if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
  {
    Error_Handler();
  }

  // 2. Liên kết ADC với DMA
  __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\7.2-Combine_test_with interupt\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;

UART_HandleTypeDef huart6;

/* USER CODE BEGIN PV */
// --- Biến cho giao tiếp UART với Module Wi-Fi ---
I2C_LCD_HandleTypeDef lcd;
uint8_t uart_rx_byte;
char response_buffer[200];
uint8_t response_index = 0;
volatile uint8_t data_received_flag = 0;

typedef enum {
    WIFI_STATE_CONNECTING,
    WIFI_STATE_GET_INFO,
    WIFI_STATE_CONNECTED
} WifiState_t;

WifiState_t wifi_state = WIFI_STATE_CONNECTING;

char line1_str[20];
char line2_str[20];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART6_UART_Init(void);
/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void LCD_Init_Custom()
{
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);
}

int send_at_command(const char* command, const char* expected_response, uint32_t timeout)
{
    // Xóa bộ đệm cũ
    memset(response_buffer, 0, sizeof(response_buffer));
    response_index = 0;

    // Gửi lệnh
    HAL_UART_Transmit(&huart6, (uint8_t*)command, strlen(command), 1000);

    // Chờ cho hết thời gian timeout để thu thập toàn bộ phản hồi
    HAL_Delay(timeout);

    // Sau khi đã chờ, kiểm tra xem chuỗi phản hồi thu thập được có chứa nội dung mong muốn không
    if (strstr(response_buffer, expected_response) != NULL)
    {
        return 1; // Thành công
    }

    return 0; // Thất bại
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- KHỞI TẠO --- */
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART6_UART_Init();

  /* USER CODE BEGIN 2 */
  // Khởi tạo LCD và bắt đầu lắng nghe UART
  LCD_Init_Custom();
  HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);

//  // Reset module và tắt echo
//  lcd_puts(&lcd, "Set up");
//  send_at_command("AT+RST\r\n", "ready", 5000);
//  HAL_Delay(2000);
//  send_at_command("ATE0\r\n", "OK", 1000);
//  HAL_Delay(500);
//  send_at_command("AT+WMODE=1,1\r\n", "OK", 3000);
//  HAL_Delay(500);

  // Gửi lệnh kết nối Wi-Fi một lần duy nhất
  const char* connect_command = "AT+WJAP=\"Herukyatto\",\"1234567890\"\r\n";
  lcd_clear(&lcd);
  lcd_puts(&lcd, "Dang ket noi...");
  HAL_UART_Transmit(&huart6, (uint8_t*)connect_command, strlen(connect_command), 1000);
  /* USER CODE END 2 */

  /* Infinite loop */
  while (1)
  {
    // Đây là một máy trạng thái (state machine) đơn giản
	    switch (wifi_state)
	    {
	      case WIFI_STATE_CONNECTING:
	        // Trạng thái chờ sự kiện WIFI_GOT_IP
	        // Dựa trên quan sát thực tế của bạn, chuỗi này có dấu gạch dưới
	        if (strstr(response_buffer, "+EVENT:WIFI_GOT_IP") != NULL)
	        {
	          lcd_clear(&lcd);
	          lcd_puts(&lcd, "KET NOI THANH CONG!");
	          HAL_Delay(2000);
	          wifi_state = WIFI_STATE_GET_INFO; // Chuyển sang trạng thái lấy thông tin
	        }
	        break;

	      case WIFI_STATE_GET_INFO:
	        // Trạng thái gửi lệnh lấy thông tin
	        lcd_clear(&lcd);
	        lcd_puts(&lcd, "Lay thong tin...");
	        // Sử dụng AT+WJAP? để lấy thông tin
	        if (send_at_command("AT+WJAP?\r\n", "OK", 3000))
	        {
	            // --- XỬ LÝ CHUỖI ĐỂ LẤY IP VÀ MAC ---
	            char ip_addr[16] = "Not Found";
	            char mac_addr[18] = "Not Found";
	            char temp_buffer[200];
	            strcpy(temp_buffer, response_buffer);

	            char *token = strtok(temp_buffer, ",");
	            int token_count = 0;
	            while(token != NULL)
	            {
	                // Dựa trên định dạng, IP là token thứ 8, MAC là token thứ 6
	                if(token_count == 5) {
	                    strncpy(mac_addr, token, 17);
	                    mac_addr[17] = '\0';
	                } else if(token_count == 7) {
	                    strncpy(ip_addr, token, 15);
	                    ip_addr[15] = '\0';
	                }
	                token = strtok(NULL, ",");
	                token_count++;
	            }

	            // In kết quả đã xử lý
	            lcd_clear(&lcd);
	            sprintf(line1_str, "IP: %s", ip_addr);
	            sprintf(line2_str, "MAC:%s", mac_addr);
	            lcd_puts(&lcd, line1_str);
	            lcd_gotoxy(&lcd, 0, 1);
	            lcd_puts(&lcd, line2_str);

	            wifi_state = WIFI_STATE_CONNECTED;
	        }
	        else
	        {
	            lcd_clear(&lcd);
	            lcd_puts(&lcd, "Loi lay thong tin");
	            HAL_Delay(2000);
	        }
	        break;

	      case WIFI_STATE_CONNECTED:
	        // Đã kết nối và lấy thông tin xong, không làm gì cả
	        break;
	    }
  }
}


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LED_ON_BOARD_Pin */
  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART6)
  {
    // Chỉ ghép ký tự vào bộ đệm, không đặt cờ báo nữa
    if (response_index < sizeof(response_buffer) - 1)
    {
      // Thay thế ký tự xuống dòng bằng dấu cách để dễ hiển thị trên 1 dòng
      if(uart_rx_byte == '\r' || uart_rx_byte == '\n')
      {
          response_buffer[response_index++] = ' ';
      }
      else
      {
          response_buffer[response_index++] = uart_rx_byte;
      }
    }

    // Luôn lắng nghe byte tiếp theo
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);
  }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\8.Wifi_module\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\.settings\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Core\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Core\Src\main.c 
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define WIFI_SSID       "Herukyatto"
#define WIFI_PASSWORD   "1234567890"
#define LOCAL_API_IP    "192.168.1.112"
#define LOCAL_API_PORT  5000
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;

UART_HandleTypeDef huart6;

/* USER CODE BEGIN PV */
I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;

// --- Biến cho logic không-chặn ---
volatile uint32_t ms_ticks = 0; // Biến nhịp tim (cần TIM4 interrupt để cập nhật)
uint32_t last_api_send_time = 0;

// --- Biến Trạng thái (State Machine) ---
typedef enum {
    APP_STATE_WIFI_CONNECT,
    APP_STATE_WIFI_CONNECTED,
    APP_STATE_RUNNING
} AppState_t;
AppState_t app_state = APP_STATE_WIFI_CONNECT;

// --- Biến UART ---
uint8_t uart_rx_byte;
char response_buffer[200];
uint8_t response_index = 0;

// --- Các biến khác ---
float temperature, humidity;
char line1_str[20];
char line2_str[20];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART6_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void LCD_Init_Custom()
{
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);
}

int send_at_command(const char* command, const char* expected_response, uint32_t timeout)
{
    // Xóa bộ đệm cũ
    memset(response_buffer, 0, sizeof(response_buffer));
    response_index = 0;

    // Gửi lệnh
    HAL_UART_Transmit(&huart6, (uint8_t*)command, strlen(command), 1000);

    // Chờ cho hết thời gian timeout để thu thập toàn bộ phản hồi
    HAL_Delay(timeout);

    // Sau khi đã chờ, kiểm tra xem chuỗi phản hồi thu thập được có chứa nội dung mong muốn không
    if (strstr(response_buffer, expected_response) != NULL)
    {
        return 1; // Thành công
    }

    return 0; // Thất bại
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- KHỞI TẠO --- */
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART6_UART_Init();

  /* USER CODE BEGIN 2 */
  // Khởi tạo các module
  LCD_Init_Custom();
  DwtInit();
  dht22.DataPort = DHT22_GPIO_Port;
  dht22.DataPin = DHT22_Pin;
  dht22.Type = DHT22;
  HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);

  // --- KẾT NỐI WI-FI ---
//  lcd_puts(&lcd, "Dang ket noi Wifi...");
//  send_at_command("AT+RST\r\n", "ready", 5000);
//  HAL_Delay(2000);
//  send_at_command("ATE0\r\n", "OK", 1000);
//  HAL_Delay(500);
//  send_at_command("AT+WMODE=1,1\r\n", "OK", 3000);
//  HAL_Delay(500);

  /* Infinite loop */
    while (1)
    {
      switch (app_state)
      {
        case APP_STATE_WIFI_CONNECT:
          lcd_clear(&lcd);
          lcd_puts(&lcd, "Connecting WiFi...");

          send_at_command("AT+RST\r\n", "ready", 5000);
          HAL_Delay(2000);
          send_at_command("ATE0\r\n", "OK", 1000);
          HAL_Delay(500);
          send_at_command("AT+WMODE=1,1\r\n", "OK", 3000);
          HAL_Delay(500);

          char connect_command[100];
          sprintf(connect_command, "AT+WJAP=\"%s\",\"%s\"\r\n", WIFI_SSID, WIFI_PASSWORD);

          if (send_at_command(connect_command, "+EVENT:WIFI_GOT_IP", 15000))
          {
            lcd_clear(&lcd);
            lcd_puts(&lcd, "WiFi Connected!");
            HAL_Delay(2000);
            app_state = APP_STATE_RUNNING; // Chuyển sang trạng thái hoạt động chính
          }
          else
          {
            lcd_clear(&lcd);
            lcd_puts(&lcd, "WiFi Failed!");
            HAL_Delay(5000); // Đợi 5 giây rồi thử lại
          }
          break;

        case APP_STATE_RUNNING:
          // Logic chính của chương trình sẽ nằm ở đây
          // Chỉ gửi API mỗi 10 giây
          //if (ms_ticks - last_api_send_time >= 10000) // Dùng logic không-chặn
          //{
              // last_api_send_time = ms_ticks;

              // 1. Đọc cảm biến
              DHT_GetData(&dht22);
              temperature = dht22.Temperature;
              humidity = dht22.Humidity;

              // Hiển thị lên LCD
              sprintf(line1_str, "Temp: %.1f C", temperature);
              sprintf(line2_str, "Humi: %.1f %%", humidity);
              lcd_clear(&lcd);
              lcd_gotoxy(&lcd, 0, 0);
              lcd_puts(&lcd, line1_str);
              lcd_gotoxy(&lcd, 0, 1);
              lcd_puts(&lcd, line2_str);

              // 2. Chuẩn bị và gửi API
              char json_payload[100];
              sprintf(json_payload, "{\\\"temperature\\\":%.1f,\\\"humidity\\\":%.1f}", temperature, humidity);

              char http_command[256];
              sprintf(http_command, "AT+HTTPCLIENTLINE=1,3,\"application/json\",\"%s\",%d,/api/data,%s\r\n",
                      LOCAL_API_IP, LOCAL_API_PORT, json_payload);

              send_at_command(http_command, "OK", 10000);
          //}
          HAL_Delay(10000); // Tạm thời vẫn dùng Delay để test
          break;

        case APP_STATE_WIFI_CONNECTED:
                // Không làm gì cả
                break;
      }
    }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin : DHT22_Pin */
  GPIO_InitStruct.Pin = DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(DHT22_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART6)
  {
    // Chỉ ghép ký tự vào bộ đệm, không đặt cờ báo nữa
    if (response_index < sizeof(response_buffer) - 1)
    {
      // Thay thế ký tự xuống dòng bằng dấu cách để dễ hiển thị trên 1 dòng
      if(uart_rx_byte == '\r' || uart_rx_byte == '\n')
      {
          if (response_index > 0) // Chỉ đặt cờ nếu đã có dữ liệu
          {
//        	  data_received_flag = 1;
          }
      }
      else
      {
          response_buffer[response_index++] = uart_rx_byte;
      }
    } else {
    	// Tràn bộ đệm, reset lại
    	response_index = 0;
    }

    // Luôn lắng nghe byte tiếp theo
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1);
  }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Core\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Core\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Core\Startup\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Debug\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\ST\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\ST\STM32F4xx\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\ST\STM32F4xx\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\ST\STM32F4xx\Source\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Device\ST\STM32F4xx\Source\Templates\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\CMSIS\Include\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\STM32F4xx_HAL_Driver\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\STM32F4xx_HAL_Driver\Inc\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\main.c 
 
--- File: main.c --- 
// D:\Learn\C\C\STM32F411\9-Wifi_with_Local_API\Drivers\STM32F4xx_HAL_Driver\Src\main.c 
