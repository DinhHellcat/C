//main.c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#define ON          1
#define OFF         0
#define DEBUG_LCD  OFF

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
#if DEBUG_LCD == ON
I2C_HandleTypeDef hi2c1;
#endif
UART_HandleTypeDef huart6;

I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht11;

char rx_buffer_poll[256];
uint16_t rx_index = 0;
char at_resp_buffer[512];

/* Private function prototypes -----------------------------------------------*/
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
#if DEBUG_LCD == ON
static void MX_I2C1_Init(void);
#endif
static void MX_USART6_UART_Init(void);

void annouce_buzzer(int timeout);
void relaytest(uint32_t timeout, int relay_id);
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config();

  MX_GPIO_Init();
  MX_ADC1_Init();
#if DEBUG_LCD == ON
    MX_I2C1_Init();
#endif
  MX_USART6_UART_Init();

  annouce_buzzer(150);
  relaytest(1000,1);
  relaytest(1000,2);
  annouce_buzzer(150);

//  while(1){}
  /* Start Application Logic */
  App_Main_Loop();
}

/* ============================================================================== */
/* APPLICATION LOGIC (Moved here to avoid Linker Error)                           */
/* ============================================================================== */

void App_Main_Loop(void)
{
    DwtInit();

#if DEBUG_LCD == ON
    lcd.hi2c = &hi2c1;
    lcd.address = 0x4E;
    lcd_init(&lcd);
    HAL_Delay(100);
    lcd_init(&lcd);

    lcd_clear(&lcd);
    lcd_puts(&lcd, "Booting F446...");
    HAL_Delay(1000);
#endif
    dht11.DataPort = DHT_Port;
    dht11.DataPin = DHT_Pin;
    dht11.Type = DHT11;

    annouce_buzzer(150);

    WiFi_Connect_Polling();
#if DEBUG_LCD == ON
    lcd_clear(&lcd);
    lcd_puts(&lcd, "Ready: ");
    lcd_puts(&lcd, DEVICE_NODE_ID);
#endif

    uint32_t last_tick = HAL_GetTick();

    while (1)
    {
        UART_Poll_And_Parse();

        if (HAL_GetTick() - last_tick >= SEND_INTERVAL)
        {
            last_tick = HAL_GetTick();

            DHT_GetData(&dht11);
            uint32_t mq2 = ADC_Read_Polling(ADC_CHANNEL_0);
            uint32_t mq135 = ADC_Read_Polling(ADC_CHANNEL_1);
            uint8_t pir = HAL_GPIO_ReadPin(PIR_Port, PIR_Pin);

            char json[128];
            sprintf(json, "{\"id\":\"%s\",\"t\":%.1f,\"h\":%.1f,\"mq2\":%lu,\"mq135\":%lu,\"pir\":%d}\n",
                    DEVICE_NODE_ID, dht11.Temperature, dht11.Humidity, mq2, mq135, pir);

            HAL_UART_Transmit(&huart6, (uint8_t*)json, strlen(json), 100);

#if DEBUG_LCD == ON
            char disp[20];
            lcd_gotoxy(&lcd, 0, 0);
            sprintf(disp, "T:%.0f G:%lu P:%d   ", dht11.Temperature, mq2, pir);
            lcd_puts(&lcd, disp);
#endif
        }
    }
}

void UART_Poll_And_Parse(void)
{
    uint8_t byte;
    if (HAL_UART_Receive(&huart6, &byte, 1, 0) == HAL_OK)
    {
        if (byte == '\n' || byte == '\r')
        {
            if (rx_index > 0)
            {
                rx_buffer_poll[rx_index] = 0;
                Process_Downlink(rx_buffer_poll);
                rx_index = 0;
            }
        }
        else
        {
            if (rx_index < sizeof(rx_buffer_poll) - 1)
            {
                rx_buffer_poll[rx_index++] = (char)byte;
            }
        }
    }
}

void Process_Downlink(char* cmd)
{
    char type[10];
    int value;

    if (sscanf(cmd, "CMD:%[^:]:%d", type, &value) == 2)
    {
#if DEBUG_LCD == ON
        lcd_gotoxy(&lcd, 0, 1);
        char lcd_msg[17];
        sprintf(lcd_msg, "Set %s->%d   ", type, value);
        lcd_puts(&lcd, lcd_msg);
#endif
        GPIO_PinState state = (value == 1) ? GPIO_PIN_SET : GPIO_PIN_RESET;

        if (strcmp(type, "RELAY") == 0) HAL_GPIO_WritePin(RELAY1_Port, RELAY1_Pin, state);
        else if (strcmp(type, "RELAY1") == 0) HAL_GPIO_WritePin(RELAY1_Port, RELAY1_Pin, state);
        else if (strcmp(type, "RELAY2") == 0) HAL_GPIO_WritePin(RELAY2_Port, RELAY2_Pin, state);
        else if (strcmp(type, "RELAY3") == 0) HAL_GPIO_WritePin(RELAY3_Port, RELAY3_Pin, state);
        else if (strcmp(type, "MQ2") == 0) HAL_GPIO_WritePin(RELAY1_Port, RELAY1_Pin, state);
    }
}

int AT_Send_And_Wait(char* cmd, char* expected, uint32_t timeout_ms)
{
    uint8_t dump;
    while(HAL_UART_Receive(&huart6, &dump, 1, 0) == HAL_OK);

    HAL_UART_Transmit(&huart6, (uint8_t*)cmd, strlen(cmd), 100);

    uint32_t start = HAL_GetTick();
    uint16_t idx = 0;
    memset(at_resp_buffer, 0, sizeof(at_resp_buffer));

    while (HAL_GetTick() - start < timeout_ms)
    {
        uint8_t byte;
        if (HAL_UART_Receive(&huart6, &byte, 1, 1) == HAL_OK)
        {
            if (idx < sizeof(at_resp_buffer) - 1)
            {
                at_resp_buffer[idx++] = (char)byte;
                if (strstr(at_resp_buffer, expected) != NULL) return 1;
            }
        }
    }
    return 0;
}

void WiFi_Connect_Polling(void)
{
#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Checking AT...");
#endif
    while (!AT_Send_And_Wait("AT\r\n", "OK", 750)) {
#if DEBUG_LCD == ON
        lcd_gotoxy(&lcd, 0, 1); lcd_puts(&lcd, "Retrying... ");
        HAL_Delay(500);
#endif
    }
#if DEBUG_LCD == ON
    lcd_gotoxy(&lcd, 0, 1); lcd_puts(&lcd, "AT OK!      ");
#endif
    annouce_buzzer(500);

#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Setting Mode...");
#endif
    AT_Send_And_Wait("AT+RST\r\n", "ready", 5000);
    HAL_Delay(2000);
    AT_Send_And_Wait("ATE0\r\n", "OK", 1000);
    while (!AT_Send_And_Wait("AT+WMODE=1,1\r\n", "OK", 2000)) {
        HAL_Delay(500);
    }
#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Connecting WiFi");
#endif
    char cmd[128];
    sprintf(cmd, "AT+WJAP=%s,%s\r\n", WIFI_SSID, WIFI_PASSWORD);
    while (!AT_Send_And_Wait(cmd, "+EVENT:WIFI_GOT_IP", 20000)) {
#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "WiFi Fail!");
#endif
        HAL_Delay(2000);
#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Retrying...");
#endif
    }
#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "WiFi Connected!");
#endif
    annouce_buzzer(200);
    HAL_Delay(200);
    annouce_buzzer(200);

#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Link Server...");
#endif
    sprintf(cmd, "AT+SOCKET=4,%s,%d\r\n", SERVER_IP, SERVER_PORT);
    while (!AT_Send_And_Wait(cmd, "connect success", 5000)) {
#if DEBUG_LCD == ON
    lcd_gotoxy(&lcd, 0, 1); lcd_puts(&lcd, "Retrying... ");
#endif
        HAL_Delay(2000);
    }

#if DEBUG_LCD == ON
    lcd_clear(&lcd); lcd_puts(&lcd, "Transparent...");
#endif
    AT_Send_And_Wait("AT+SOCKETTT\r\n", ">", 3000);
    annouce_buzzer(200);
    HAL_Delay(200);
    annouce_buzzer(200);
    HAL_Delay(200);
    annouce_buzzer(200);
}

uint32_t ADC_Read_Polling(uint32_t channel) {
    ADC_ChannelConfTypeDef sConfig = {0};
    sConfig.Channel = channel;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) Error_Handler();

    HAL_ADC_Start(&hadc1);
    uint32_t val = 0;
    if (HAL_ADC_PollForConversion(&hadc1, 100) == HAL_OK) {
        val = HAL_ADC_GetValue(&hadc1);
    }
    HAL_ADC_Stop(&hadc1);
    return val;
}

// Clock Config cho F446 (100MHz)
void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
}

static void MX_ADC1_Init(void) {
  __HAL_RCC_ADC1_CLK_ENABLE();
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 1;
  HAL_ADC_Init(&hadc1);
}

#if DEBUG_LCD == ON
static void MX_I2C1_Init(void) {
  __HAL_RCC_I2C1_CLK_ENABLE();
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  HAL_I2C_Init(&hi2c1);
}
#endif

static void MX_USART6_UART_Init(void) {
  __HAL_RCC_USART6_CLK_ENABLE();
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart6);
}

static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  // OUTPUT PINS
  GPIO_InitStruct.Pin = RELAY1_Pin | RELAY2_Pin | RELAY3_Pin | LED_TEST_Pin | BUZZER_TEST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  // INPUT PINS
  GPIO_InitStruct.Pin = PIR_Pin | DHT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  // ANALOG PINS
  GPIO_InitStruct.Pin = MQ2_Pin | MQ135_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  HAL_GPIO_WritePin(GPIOA, RELAY1_Pin | RELAY2_Pin | RELAY3_Pin, GPIO_PIN_RESET);
}

void annouce_buzzer(int timeout)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
    HAL_Delay(timeout);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
}

void relaytest(uint32_t timeout, int relay_id)
{
    GPIO_TypeDef* port = GPIOA; // Giá trị mặc định
    uint16_t pin = 0;

    // Chọn Pin và Port dựa trên số thứ tự
    switch(relay_id)
    {
        case 1:
            port = Relay1_Port;
            pin = Relay1_Pin;
            break;
        case 2:
            port = Relay2_Port;
            pin = Relay2_Pin;
            break;
        case 3:
            port = Relay3_Port;
            pin = Relay3_Pin;
            break;
        default:
            return; // Nếu nhập số sai thì thoát luôn
    }

    // Thực hiện bật tắt
    HAL_GPIO_WritePin(port, pin, GPIO_PIN_SET);
    HAL_Delay(timeout);
    HAL_GPIO_WritePin(port, pin, GPIO_PIN_RESET);
}

void Error_Handler(void) {
  __disable_irq();
  while (1) {}
}
