/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Project 11.1_DHTwithHotspot
  * @author         :
  * @version        : 1.0
  ******************************************************************************
  * @attention
  *
  * Phiên bản rút gọn từ 11.Final, chỉ tập trung vào DHT22 và gửi API qua WiFi.
  *
  * - Lập trình không-chặn (Non-blocking) sử dụng Timer Interrupt (TIM4).
  * - Giao tiếp UART không-chặn với WiFi module sử dụng Interrupt.
  * - Tích hợp cảm biến: DHT22.
  * - Hiển thị thông tin qua I2C LCD.
  * - Máy trạng thái (State Machine) để quản lý logic chương trình.
  *
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c_lcd.h"
#include "dhtxx.h"
#include "dwt.h"
#include <stdio.h>
#include <string.h>

/* Private defines -----------------------------------------------------------*/
#define WIFI_SSID       "Herukyatto"
#define WIFI_PASSWORD   "1234567890"
#define LOCAL_API_IP    "10.13.71.41"
#define LOCAL_API_PORT  5000

// #define GAS_ALARM_THRESHOLD 1500 // Đã loại bỏ
#define MAIN_LOGIC_INTERVAL 1000 // Thời gian thực thi logic chính (ms)
#define API_SEND_INTERVAL   10000 // Thời gian giữa 2 lần gửi API (ms)

/* Private typedef -----------------------------------------------------------*/
typedef enum {
    APP_STATE_INIT,
    APP_STATE_WIFI_CONNECT,
    APP_STATE_RUNNING
} AppState_t;

/* Private variables ---------------------------------------------------------*/
// --- Handles cho các ngoại vi và thư viện ---
// ADC_HandleTypeDef hadc1; // Đã loại bỏ
// DMA_HandleTypeDef hdma_adc1; // Đã loại bỏ
I2C_HandleTypeDef hi2c1;
// TIM_HandleTypeDef htim2; // Đã loại bỏ
TIM_HandleTypeDef htim4; // Dùng cho "nhịp tim" hệ thống
UART_HandleTypeDef huart6; // Dùng cho WiFi Module

I2C_LCD_HandleTypeDef lcd;
DHTxx_Drv_t dht22;

// --- Biến cho hệ thống và logic không-chặn ---
volatile uint32_t ms_ticks = 0; // Biến "nhịp tim", được tăng trong ngắt TIM4
uint32_t last_main_logic_time = 0;
uint32_t last_api_send_time = 0;
AppState_t app_state = APP_STATE_INIT;

// --- Biến lưu giá trị cảm biến ---
float temperature = 0.0f, humidity = 0.0f;
// uint32_t pir_state = 0; // Đã loại bỏ
// uint32_t adc_dma_buffer[2]; // Đã loại bỏ

// --- Biến cho giao tiếp UART ---
uint8_t uart_rx_byte;
char response_buffer[256];
uint8_t response_index = 0;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
// static void MX_DMA_Init(void); // Đã loại bỏ
// static void MX_ADC1_Init(void); // Đã loại bỏ
static void MX_I2C1_Init(void);
// static void MX_TIM2_Init(void); // Đã loại bỏ
static void MX_TIM4_Init(void);
static void MX_USART6_UART_Init(void);

// static void Manual_DMA_Link_Init(void); // Đã loại bỏ
static int send_at_command(const char* command, const char* expected_response, uint32_t timeout);

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* --- 1. KHỞI TẠO CƠ BẢN --- */
  HAL_Init();
  SystemClock_Config();

  /* --- 2. KHỞI TẠO CÁC NGOẠI VI --- */
  MX_GPIO_Init();
  // MX_DMA_Init(); // Đã loại bỏ
  // MX_ADC1_Init(); // Đã loại bỏ
  MX_I2C1_Init();
  // MX_TIM2_Init(); // Đã loại bỏ
  MX_TIM4_Init();
  MX_USART6_UART_Init();

  /* --- 3. KHỞI TẠO CÁC THƯ VIỆN VÀ TIẾN TRÌNH NỀN --- */
  DwtInit(); // Khởi tạo DWT cho các hàm delay us

  // Khởi tạo LCD
  lcd.hi2c = &hi2c1;
  lcd.address = 0x4E;
  lcd_init(&lcd);
  lcd_puts(&lcd, "System Init...");

  // Khởi tạo DHT22 (PA5)
  dht22.DataPort = DHT22_GPIO_Port;
  dht22.DataPin = DHT22_Pin;
  dht22.Type = DHT22;

  // Manual_DMA_Link_Init(); // Đã loại bỏ
  // HAL_ADC_Start_DMA(&hadc1, adc_dma_buffer, 2); // Đã loại bỏ

  // Bắt đầu các tiến trình không-chặn
  HAL_TIM_Base_Start_IT(&htim4);          // Bắt đầu "nhịp tim" hệ thống
  // HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3); // Đã loại bỏ
  HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1); // Bắt đầu lắng nghe UART

  // Thiết lập trạng thái ban đầu
  // __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_3, 500); // Đã loại bỏ
  app_state = APP_STATE_WIFI_CONNECT;

  /* --- 4. VÒNG LẶP CHÍNH (SUPER LOOP) --- */
  while (1)
  {
    switch (app_state)
    {
        case APP_STATE_WIFI_CONNECT:
        {
        	lcd_clear(&lcd);
			lcd_puts(&lcd, "Checking AT...");
			if (send_at_command("AT\r\n", "OK", 1000)) {
				lcd_gotoxy(&lcd, 0, 1);
				lcd_puts(&lcd, "AT OK");
			} else {
				lcd_gotoxy(&lcd, 0, 1);
				lcd_puts(&lcd, "AT FAIL");
				while(1); // Dừng ở đây nếu AT cơ bản lỗi
			}
			HAL_Delay(1000);

            lcd_clear(&lcd);
            lcd_puts(&lcd, "Reseting");

            send_at_command("AT+RST\r\n", "ready", 5000);
			HAL_Delay(2000); // Chờ module khởi động lại
			send_at_command("ATE0\r\n", "OK", 1000);
			HAL_Delay(500);
			send_at_command("AT+WMODE=1,1\r\n", "OK", 3000); // Đặt làm Station Mode
			HAL_Delay(500);

			lcd_clear(&lcd);
			lcd_puts(&lcd, "Connecting WiFi...");

			char connect_cmd[100];
			sprintf(connect_cmd, "AT+WJAP=\"%s\",\"%s\"\r\n", WIFI_SSID, WIFI_PASSWORD);

			if (send_at_command(connect_cmd, "+EVENT:WIFI_GOT_IP", 20000))
			{
				lcd_clear(&lcd);
				lcd_puts(&lcd, "WiFi Connected!");
				HAL_Delay(2000);
				app_state = APP_STATE_RUNNING;
				last_main_logic_time = ms_ticks;
				last_api_send_time = ms_ticks;
			}
			else
			{
				lcd_clear(&lcd);
				lcd_puts(&lcd, "WiFi Failed!");
				lcd_gotoxy(&lcd, 0, 1);
				char error_msg[17];
				strncpy(error_msg, response_buffer, 16);
				error_msg[16] = '\0';
				lcd_puts(&lcd, error_msg);
				HAL_Delay(5000); // Chờ 5 giây trước khi thử lại
			}
			break;
		}

        case APP_STATE_RUNNING:
        {
            // Logic chính chỉ thực thi định kỳ, không làm liên tục
            if (ms_ticks - last_main_logic_time >= MAIN_LOGIC_INTERVAL)
            {
                last_main_logic_time = ms_ticks;

                // --- 1. ĐỌC DỮ LIỆU CẢM BIẾN ---
                DHT_GetData(&dht22);
                temperature = dht22.Temperature;
                humidity = dht22.Humidity;
                // pir_state = HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin); // Đã loại bỏ
                // uint32_t mq2_val = adc_dma_buffer[0]; // Đã loại bỏ
                // uint32_t mq135_val = adc_dma_buffer[1]; // Đã loại bỏ

                char line1_str[20], line2_str[20];

                // --- 2. XỬ LÝ LOGIC (ĐÃ GIẢN LƯỢC) ---
                // Chỉ hiển thị thông tin DHT22
//                HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);
                sprintf(line1_str, "Temp: %.1f C", temperature);
                sprintf(line2_str, "Humi: %.1f %%", humidity);


                // --- 3. CẬP NHẬT LCD ---
                lcd_clear(&lcd);
                lcd_puts(&lcd, line1_str);
                lcd_gotoxy(&lcd, 0, 1);
                lcd_puts(&lcd, line2_str);
            }

            // Logic gửi API cũng thực thi định kỳ và độc lập
            if (ms_ticks - last_api_send_time >= API_SEND_INTERVAL)
            {
                last_api_send_time = ms_ticks;

                // Chuẩn bị payload JSON (chỉ chứa nhiệt độ và độ ẩm)
                char json_payload[100];
                sprintf(json_payload, "{\\\"temperature\\\":%.1f,\\\"humidity\\\":%.1f}", temperature, humidity);

                // Chuẩn bị lệnh HTTP
                char http_cmd[300];
                sprintf(http_cmd, "AT+HTTPCLIENTLINE=1,3,\"application/json\",\"%s\",%d,\"/api/data\",\"%s\"\r\n",
                        LOCAL_API_IP, LOCAL_API_PORT, json_payload);

                // Gửi và hiển thị trạng thái
                lcd_gotoxy(&lcd, 12, 1); // Vị trí góc phải dưới
                if(send_at_command(http_cmd, "OK", 10000)) {
                    lcd_puts(&lcd, "->OK");
                } else {
                    lcd_puts(&lcd, "->FAIL");
                }
            }
            break;
        }

        case APP_STATE_INIT:
        default:
            // Trạng thái khởi tạo, không làm gì cả, chờ chuyển sang WIFI_CONNECT
            break;
    }
  }
}

/* --- CÁC HÀM KHỞI TẠO NGOẠI VI (MX_...) --- */

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; // CHỌN HSI
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; // NGUỒN CHO PLL LÀ HSI
  RCC_OscInitStruct.PLL.PLLM = 8; // 16MHz / 8 = 2MHz
  RCC_OscInitStruct.PLL.PLLN = 100; // 2MHz * 100 = 200MHz
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; // 200MHz / 2 = 100MHz (SYSCLK)
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; // LẤY XUNG TỪ PLL
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

// static void MX_ADC1_Init(void) // Đã loại bỏ
// {
// }

static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) Error_Handler();
}

// static void MX_TIM2_Init(void) // Đã loại bỏ
// {
// }

static void MX_TIM4_Init(void) // System Heartbeat Timer
{
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 99; // For 1MHz clock
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 999;   // Interrupt every 1000 * 1us = 1ms
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK) Error_Handler();
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK) Error_Handler();
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK) Error_Handler();
}

static void MX_USART6_UART_Init(void)
{
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK) Error_Handler();
}

// static void MX_DMA_Init(void) // Đã loại bỏ
// {
// }

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

//  HAL_GPIO_WritePin(LED_ON_BOARD_GPIO_Port, LED_ON_BOARD_Pin, GPIO_PIN_RESET);

  // Chỉ khởi tạo DHT22 Pin (PA5)
  GPIO_InitStruct.Pin = DHT22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

//  GPIO_InitStruct.Pin = LED_ON_BOARD_Pin;
//  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
//  GPIO_InitStruct.Pull = GPIO_NOPULL;
//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
//  HAL_GPIO_Init(LED_ON_BOARD_GPIO_Port, &GPIO_InitStruct);
}

/* --- CÁC HÀM HỖ TRỢ VÀ CALLBACK --- */

// static void Manual_DMA_Link_Init(void) // Đã loại bỏ
// {
// }

/**
  * @brief  Hàm gửi lệnh AT và chờ phản hồi (vẫn còn blocking).
  */
int send_at_command(const char* command, const char* expected_response, uint32_t timeout)
{
    memset(response_buffer, 0, sizeof(response_buffer));
    response_index = 0;
    HAL_UART_Transmit(&huart6, (uint8_t*)command, strlen(command), 1000);

    uint32_t start_time = HAL_GetTick();
    while (HAL_GetTick() - start_time < timeout)
    {
        if (strstr(response_buffer, expected_response) != NULL)
        {
            return 1; // Success
        }
        HAL_Delay(10);
    }
    return 0; // Fail
}

/**
  * @brief  Callback được gọi mỗi khi một Timer kết thúc chu kỳ đếm.
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM4) // Kiểm tra có phải "nhịp tim" từ TIM4 không
  {
    ms_ticks++; // Tăng biến đếm mili giây
  }
}

/**
  * @brief  Callback được gọi mỗi khi nhận được 1 byte qua UART.
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART6)
  {
    if (response_index < sizeof(response_buffer) - 1)
    {
      response_buffer[response_index++] = uart_rx_byte;
    }
    HAL_UART_Receive_IT(&huart6, &uart_rx_byte, 1); // Lắng nghe byte tiếp theo
  }
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
